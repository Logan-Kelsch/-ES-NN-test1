print("TESTED FEATURES: ")
print(Xfeatures)
print("TESTING FOR: ")
print(Yfeatures)
#PROCESS THE DATA-------------------------------------------------------

# Separate features and target
X = data.iloc[:, :-1].values
y = data.iloc[:, -1].values

#setting data for LSTM
def reformat_to_lstm(X, time_steps=timeSteps):
    X_lstm, y_lstm = [], []
    for i in range(time_steps, len(X)):
        # Collect previous time_steps rows for X
        X_lstm.append(X[i-time_steps:i])  
        # The corresponding y value for the last time step in the sequence
    X_lstm = np.array(X_lstm)
    return X_lstm

def remove_zero_mo_samples(X, y):
    # Get the 'MO' column (index 34 for 0-based indexing) for all time steps and samples
    non_zero_indices = (X[:, timeSteps-1, len(Xfeatures)-1] >= 0)
    # Filter X and y using these indices
    X_filtered = X[non_zero_indices]
    y_filtered = y[non_zero_indices]
    return X_filtered, y_filtered

t0930 = -0.321405
t1045 = -0.142368
t1200 = 0.0366699
t1600 = 10

def remove_extra_filter(X, y):
    indices = (X[:, timeSteps-1, len(Xfeatures)-3] >= -0.321405)#-3 is ToD, this value is 9:30am
    X = X[indices]
    y = y[indices]
    indices = (X[:, timeSteps-1, len(Xfeatures)-3] <= 0.0366699)#-3 is ToD, this value is 12:00pm
    X = X[indices]
    y = y[indices]
    return X, y

def tt_split(X, y, test_size=0.2):
    X, y = np.array(X), np.array(y)
    splitLoc = int(len(X)*(1-train_size))
    X_train, X_test = X[:splitLoc], X[splitLoc:]
    y_train, y_test = y[:splitLoc], y[splitLoc:]

    return X_train, X_test, y_train, y_test

train_size = 0.8
X_train, X_test, y_train, y_test = tt_split(X, y, test_size=0.2)

scaler1 = StandardScaler()
#scaler2 = RobustScaler()
#scaler3 = MinMaxScaler(feature_range=(-1,1))
scaler1.fit(X_train)

X_train = scaler1.transform(X_train)
X_test = scaler1.transform(X_test)

X_train = reformat_to_lstm(X_train, timeSteps)
X_test = reformat_to_lstm(X_test, timeSteps)

y_train = y_train[timeSteps:]
y_test = y_test[timeSteps:]

y_train = np.array(y_train)
y_test = np.array(y_test)





print(f'Raw Sample Count: {len(X)}\n')
print('X shape == {}.'.format(X.shape))
print('y shape == {}.'.format(y.shape))
#X, y = remove_zero_mo_samples(X, y)
X_train, y_train = remove_extra_filter(X_train, y_train)
X_test, y_test = remove_extra_filter(X_test, y_test)
print(f'Remaining Sample Count: {len(X)}\n')
print('X shape == {}.'.format(X.shape))
print('y shape == {}.'.format(y.shape))

#mos = X[:, timeSteps-1, len(Xfeatures)-1].mean()
#print(mos)
#print(len(X))
#print(X[0])
# Split the data into training and testing sets



#LEARNING RATES____________________________________________________________________________________________